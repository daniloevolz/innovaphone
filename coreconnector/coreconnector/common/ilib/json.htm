<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>innovaphone SDK - json.h</title>
    <!-- Take care to adjust the 3 paths if needed, e. g.: "../../web1/doc" if the file is in the common/interface folder -->
    <link rel="stylesheet" href="../../web1/doc/innovaphone.doc.css" type="text/css" />
    <link rel="stylesheet" href="../../web1/doc/vs.css">
</head>

<body>
    <script src="../../web1/doc/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <h1>JSON Library</h1>
    <p>
        JSON is a data interchange format that can be used to transmit data objects as human readable text. The innovaphone apps use JSON for all websocket protocols. This library can be used to encode and decode JSON in C++.
    </p>

    <h1>File information</h1>
    <table style="margin-left:-12px">
        <tr><td><b>File</b></td><td>common/ilib/json.h<br><br></td></tr>
        <tr><td><b><a href="#Overview">Overview</a></b></td></tr>
        <tr>
            <td><b><a href="#Classes">Classes</a></b></td>
            <td>
                <a href="#json_io">json_io</a><br>
            </td>
        </tr>
        <tr>
            <td><b>Defines</b></td>
            <td>
                <a href="#JSON_TYPE_OBJECT">JSON_TYPE_OBJECT</a><br>
                <a href="#JSON_TYPE_ARRAY">JSON_TYPE_ARRAY</a><br>
                <a href="#JSON_TYPE_VALUE">JSON_TYPE_VALUE</a><br>
                <a href="#JSON_TYPE_CONTENT_PACKET">JSON_TYPE_CONTENT_PACKET</a><br>
                <a href="#JSON_TYPE_ANY">JSON_TYPE_ANY</a><br>

                <a href="#JSON_FLAG_QUOTED">JSON_FLAG_QUOTED</a><br>
                <a href="#JSON_FLAG_INCOMPLETE">JSON_FLAG_INCOMPLETE</a><br>
                <a href="#JSON_FLAG_COMPLETE">JSON_FLAG_COMPLETE</a><br>

                <a href="#JSON_ID_ROOT">JSON_ID_ROOT</a><br>
                <a href="#JSON_ID_NONE">JSON_ID_NONE</a><br>
                <br>
            </td>
        </tr>
        <tr>
            <td><b>Examples</b></td>
            <td>
                <a href="#Example_Encoding">Encoding</a><br>
                <a href="#Example_Decoding">Decoding</a><br>
                <br>
            </td>
        </tr>
    </table>

    <h1 id="Overview">Overview</h1>
    <p>For information about the JSON structure and semantic, please refer to the <a href="https://www.rfc-editor.org/rfc/rfc8259">RFC8259</a> article. <br />This current article explains the concepts of the JSON library by innovaphone</p>
    <p>
        This library requires you to follow a specific order when adding properties to a JSON document. The document can be visualized as a tree structure, with each level representing either an object or an array. To add properties to an object, you must first add the object to the current level of the tree. Then, add all the properties to the object before moving to the next level.
        It's not possible to add another property to the same level as the object until all the properties have been added to the object.
    </p>
    <p>
        Most code explaination will be refering to this JSON Object
        <br /><pre><code class="json">{ 
    "name": "John Doe", 
    "age": 30, 
    "interests": [ 
        "programming", 
        "tv series", 
        "cooking"
    ],
    "address": {
        "street": "123 Street",
        "city": "City of New State",
        "state": "New State"
    },
    "email": "john.doe@aol.com"
}</code></pre>
    </p>
    <p>The json_io class can be used for encoding and decoding JSON messages to or from a char buffer.</p>
    <p>
        Each element has a unique numeric ID  <code>word base</code>. <br /><a href="#JSON_ID_ROOT"><code>JSON_ID_ROOT</code></a> represents the top level element. It can be no or a single element. Often the root is an object that holds all the other data. Normally json_io can be used as a stack variable. <br /> <br />A typical <b>encoding</b> flow looks like this:
<pre><code class="JS">char message[512];
json_io json(message);
word base = json.add_object(JSON_ID_ROOT, 0);
// add elements
json.encode();
</code></pre>
    </p>
    <p>
        <b>Decoding</b> is usually done like this:
<pre><code class="JS">json_io json(message);
json.decode();
word base = recv.get_object(JSON_ID_ROOT, 0);
// read elements
</code></pre>
    </p>
    <p>
        There are two different methods for traversing the JSON structure: <br />Inside <b>objects</b> the elements are referenced by their name.
        <pre><code class="JS">// adding elements
json.add_string(base, "name", "John Doe");
// reading elements
const char * name = json.get_string(base, "name");</code></pre>
    </p>
    <p>
        Inside <b>arrays</b> the elements are enumerated.
        <pre><code class="JS">// adding elements
json.add_string(base, 0, "programming");
json.add_string(base, 0, "tv series");
json.add_string(base, 0, "cooking");
// reading elements
word last = 0;
do {
    const char * interest = json.get_string(base, last);
}
while (last != JSON_ID_NONE);
</code></pre>
    </p>

    <p>
        Some add functions need an additional buffer for storing the values temporarily. Those buffers are called <code>char * & tmp</code> in the interface.
        Note that the buffer pointer reference is increased when adding an element.
        <pre><code class="JS">char temp[128];
char * t = temp;
json.add_attrib_printf(base, "name", t, "%s %s", "John", "Doe");
json.add_unsigned(base, "age", 30, t);
</code></pre>
    </p>

    <h3>Chunked decoding</h3>
    <p>
        Sometimes JSON objects exceed the limits of json_io, so that they cannot be decoded completely in
        one step. In this case chuncked decoding can be used. Chunked decoding works if on some level
        of the JSON object a list exists, either as array or as object, which each element of this
        list not exceeding the limits.
    </p>
    <p>Please check the JSON chunked decoding <a href="../../sdk/doc/tutorials/ChunkedJson.htm">tutorial</a> for more information.</p>
    <h1 id="Classes">Classes</h1>

    <a name="json_io"><h2>json_io</h2></a>

    <pre><code class="C++">
    class json_io {
    public:

    <a href="#constructor">json_io(char * buffer);</a>

    <a href="#reset">void reset();</a>
    <a href="#decode">bool decode();</a>
    <a href="#encode">dword encode();</a>
    <a href="#encodeOverloaded">dword encode(word handle, char * buffer);</a>
    <a href="#write">void write(word current, char * & p, word incomplete = 0xffff);</a>
    <a href="#dump">void dump();</a>

    <a href="#add">word add(byte type, byte flags, word base, const char* name, const char* info, dword len = 0xffffffff);</a>
    <a href="#add_object">word add_object(word base, const char * name);</a>
    <a href="#add_array">word add_array(word base, const char * name);</a>
    <a href="#add_string1">void add_string(word base, const char * name, const char * value, dword len=0xffffffff);</a>
    <a href="#add_string2">void add_string(word base, const char * name, const word * value, dword len, char * & tmp);</a>
    <a href="#add_string2">void add_string(word base, const char * name, const word * value, char * & tmp) { add_string(base, name, value, 0xffffffff, tmp); };</a>
    <a href="#add_replace_string">void add_replace_string(word base, const char * name, const char * value, dword len=0xffffffff);</a>
    <a href="#add_int">void add_int(word base, const char * name, int c, char * & tmp);</a>
    <a href="#add_unsigned">void add_unsigned(word base, const char * name, dword c, char * & tmp);</a>
    <a href="#add_long64">void add_long64(word base, const char * name, long64 c, char * & tmp);</a>
    <a href="#add_ulong64">void add_ulong64(word base, const char * name, ulong64 c, char * & tmp);</a>
    <a href="#add_bool">void add_bool(word base, const char * name, bool value);</a>
    <a href="#add_null">void add_null(word base, const char * name);</a>
    <a href="#add_double">void add_double(word base, const char * name, double c, char *& tmp, byte decimalPlaces = 6);</a>

    <a href="#add_printf">void add_printf(word base, const char * name, char * & tmp, const char * format, ...);</a>
    <a href="#add_printfv">void add_printfv(word base, const char * name, char * & tmp, const char * format, va_list ap);</a>
    <a href="#add_hexstring">void add_hexstring(word base, const char * name, const byte * hex, word hex_len, char * & tmp);</a>
    <a href="#add_json">void add_json(word base, const char * name, const char * value, dword len=0xffffffff);</a>

    <a href="#get_buffer">char* get_buffer()</a>
    <a href="#set_buffer">void set_buffer(char* buffer)</a>

    <a href="#get_objectByName">word get_object(word base, const char * name);</a>
    <a href="#get_objectFromArray">word get_object(word base, word & last);</a>
    <a href="#get_arrayByName">word get_array(word base, const char * name);</a>
    <a href="#get_arrayFromArray">word get_array(word base, word & last);</a>
    <a href="#get_stringByName">const char * get_string(word base, const char * name, bool * present=0);</a>
    <a href="#get_stringFromArray">const char * get_string(word base, word & last, bool * present=0);</a>
    <a href="#get_intByName">int get_int(word base, const char * name, bool * present=0);</a>
    <a href="#get_intFromArray">int get_int(word base, word & last, bool * present=0);</a>
    <a href="#get_unsignedByName">dword get_unsigned(word base, const char * name, bool * present=0);</a>
    <a href="#get_unsignedFromArray">dword get_unsigned(word base, word & last, bool * present=0);</a>
    <a href="#get_long64ByName">long64 get_long64(word base, const char * name, bool * present = 0);</a>
    <a href="#get_long64FromArray">long64 get_long64(word base, word & last, bool * present = 0);</a>
    <a href="#get_ulong64ByName">ulong64 get_ulong64(word base, const char * name, bool * present = 0);</a>
    <a href="#get_ulong64FromArray">ulong64 get_ulong64(word base, word & last, bool * present = 0);</a>
    <a href="#get_boolByName">bool get_bool(word base, const char * name, bool * present=0);</a>
    <a href="#get_boolFromArray">bool get_bool(word base, word & last, bool * present=0);</a>
    <a href="#get_bool_int">bool get_bool_int(word base, const char * name, int & iret, byte * present=0);</a>
    <a href="#get_doubleByName">double get_double(word base, const char * name, bool * present = 0);</a>
    <a href="#get_doubleFromArray">double get_double(word base, word & last, bool * present = 0);</a>

    <a href="#get_flags">byte get_flags(word handle);</a>
    <a href="#get_next">word get_next(word base, word last, byte & type, byte & flags, const char * & name, const char * & info);</a>
    <a href="#get_index">word get_index();</a>
    <a href="#get_name">const char * get_name(word handle);</a>
    <a href="#get_info">const char * get_info(word handle);</a>
    <a href="#get_count">word get_count(word handle);</a>
    <a href="#get_valueByName">const char* get_value(word base, byte flags, const char* name, bool * present=0);</a>
    <a href="#get_valueLast">const char* get_value(word base, byte flags, word& last, bool * present=0);</a>

    <a href="#trace">void trace(class debug_printf * dbg, word base, word level = 0);</a>
    <a href="#to_url">word to_url(word base, char * b, word l, const char * prefix = 0, bool cont = false);</a>

    <a href="#last">char * last;</a>
    <a href="#name_last">char * name_last;</a>
    <a href="#incomplete">char * incomplete;</a>
    <a href="#max_item">unsigned max_item;</a>

    };
</code></pre>

    <h3>Public functions</h3>

    <div id="constructor" class="fnhead">json_io(constructor)</div>
    <dd>
        Initializes the json_io structure.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">char * <b>buffer</b></td><td>The buffer for the message.</td></tr>
        </table>

        <h4>Remarks</h4>
        The buffer is mandatory for decoding. For encoding it is optional but if it's null a buffer must be passed to the encode function. Make sure it is big enough to contain the whole message.
        Note that the buffer will be modified for both encoding and decoding.
    </dd>

    <div id="reset" class="fnhead">reset</div>
    <dd>
        Resets the internal state of the json_io structure. All added or parsed elements will be cleared from the internal state.
    </dd>

    <div id="decode" class="fnhead">decode</div>
    <dd>
        Decodes the buffer overloaded to the constructor, as JSON.
        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">bool</td><td>1 if decoding was successful, 0 if not</td></tr>
        </table>
    </dd>


    <div id="encode" class="fnhead">encode</div>
    <dd>
        Encodes the data structure into a null-terminated JSON string and writes it to the buffer specified with the constructor.

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">dword</td><td>The size of the encoded message.</td></tr>
        </table>
    </dd>

    <div id="encodeOverloaded" class="fnhead">encode (overloaded)</div>
    <dd>
        Encodes a subtree of the data structure into a null-terminated JSON string and writes it to the specified buffer.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>handle</b></td><td>The ID of the root element of the subtree.</td></tr>
            <tr><td class="param">char * <b>buffer</b></td><td>The buffer for the message.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">dword</td><td>The size of the encoded message.</td></tr>
        </table>
    </dd>

    <div id="write" class="fnhead">write</div>
    <dd>
        This function is used internally but it can also be used to encode the data structure to a JSON string in several chunks.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>current</b></td><td>The ID of the start element. Use 0 for complete data.</td></tr>
            <tr><td class="param">char *& <b>p</b></td><td>The output buffer.</td></tr>
            <tr>
                <td class="param">word <b>incomplete</b></td>
                <td>
                    The incomplete argument can be used to write only the incomplete data so that new received
                    data can be appended to the buffer an decoding started again. The incomplete argument
                    should be the handle of the descriptor of the array, with potential incomplete elements.
                </td>
            </tr>
        </table>
    </dd>

    <div id="dump" class="fnhead">dump</div>
    <dd>
        This function can be used to print the JSON string in a preset format:
        <p><b>base</b>=&lt;unique numeric identifier, pointer to base address&gt;</p>
        <p><b>count</b>=&lt;length of property value&gt;</p>
        <p><b>flags</b>=&lt;<a href="#JSON_FLAG_QUOTED">flags</a> of elements&gt;</p>
        <p>
            <pre><code class="sample">json.dump();
OUTPUT:
base=65535 count=11 flags=0 OBJECT=(NULL)/(NULL)
base=0 count=8 flags=1 VALUE=name/John Doe
base=0 count=2 flags=0 VALUE=age/30
base=0 count=3 flags=0 ARRAY=interests/(NULL)
base=3 count=11 flags=1 VALUE=(NULL)/programming
base=3 count=9 flags=1 VALUE=(NULL)/tv series
base=3 count=7 flags=1 VALUE=(NULL)/cooking
base=0 count=3 flags=0 OBJECT=address/(NULL)
base=7 count=10 flags=1 VALUE=street/123 Street
base=7 count=17 flags=1 VALUE=city/City of New State
base=7 count=9 flags=1 VALUE=state/New State
base=0 count=16 flags=1 VALUE=email/john.doe@aol.com
</code></pre>

        </p>
    </dd>


    <div id="add" class="fnhead">add</div>
    <dd>
        The function creates a new JSON element based on the provided parameters and adds it to the JSON structure under the specified base.
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">byte <b>type</b></td><td>The type of JSON element to be added</td></tr>
            <tr><td class="param">word<b>flags</b></td><td>Additional flags that can be used to modify the behavior of the added element, such as JSON_FLAG_QUOTED, which indicates that the value should be quoted.</td></tr>
            <tr><td class="param">word<b>base</b></td><td>A reference point in the JSON object hierarchy where the new element should be added.</td></tr>
            <tr><td class="param">const char*<b>name</b></td><td>The name of the JSON element to be added. This is applicable for objects and values.</td></tr>
            <tr><td class="param">const char*<b>info (optional)</b></td><td>The length of the info parameter, if applicable. If not provided, the default value is 0xffffffff.</td></tr>

        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr>
                <td class="param">word</td>
                <td>
                    The ID of the added object, representing the reference to the newly added JSON element in the structure. Can be used to add elements to the object.
                </td>
            </tr>
        </table>

        <h4>Remarks</h4>
        If the object shall be added to root level, use <a href="#JSON_ID_ROOT">JSON_ID_ROOT</a> as the base.
    </dd>

    <div id="add_object" class="fnhead">add_object</div>
    <dd>
        Adds an object to the structure.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the new element should be added.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the object. Only used when the object is inside another object. Set to 0 otherwise.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr>
                <td class="param">word</td>
                <td>
                    The ID of the added object. Can be used to add elements to the object.
                </td>
            </tr>
        </table>

        <h4>Remarks</h4>
        If the object shall be added to root level, use <a href="#JSON_ID_ROOT">JSON_ID_ROOT</a> as the base.
    </dd>

    <div id="add_array" class="fnhead">add_array</div>
    <dd>
        Adds an array to the structure.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the new element should be added.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the array. Only used when the array is inside an object. Set to 0 otherwise.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr>
                <td class="param">word</td>
                <td>
                    The ID of the added array. Can be used to add elements to the array.
                </td>
            </tr>
        </table>

        <h4>Remarks</h4>
        If the array shall be added to root level, use <a href="#JSON_ID_ROOT">JSON_ID_ROOT</a> as the base.
    </dd>

    <div id="add_string1" class="fnhead">add_string (overloaded)</div>
    <dd>
        Adds an UTF-8 string to the structure.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the new element should be added.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
            <tr><td class="param">const char * <b>value</b></td><td>The value of the element. If value is 0 the element is not added.</td></tr>
            <tr><td class="param">dword <b>len</b></td><td>The number of bytes in the value buffer. Only needed if value is not null-terminated.</td></tr>
        </table>
    </dd>

    <div id="add_string2" class="fnhead">add_string (overloaded)</div>
    <dd>
        Adds a string with 16-bit character representation to the structure.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the new element should be added.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
            <tr><td class="param">const word * <b>value</b></td><td>The value of the element. If value is 0 the element is not added.</td></tr>
            <tr><td class="param">dword <b>len</b></td><td>The number of bytes in the value buffer. Only needed if value is not null-terminated.</td></tr>
        </table>
    </dd>

    <div id="add_replace_string" class="fnhead">add_replace_string</div>
    <dd>
        Adds or replaces an existing UTF-8 string inside an object.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the new element should be added.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element (mandatory).</td></tr>
            <tr><td class="param">const char * <b>value</b></td><td>The value of the element.</td></tr>
            <tr><td class="param">dword <b>len</b></td><td>The number of bytes in the value buffer. Only needed if value is not null-terminated.</td></tr>
        </table>

        <h4>Remarks</h4>
        The function is only implemented for strings inside objects.
    </dd>

    <div id="add_int" class="fnhead">add_int</div>
    <dd>
        Adds a 32-bit signed integer to the structure.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the new element should be added.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
            <tr><td class="param">int <b>c</b></td><td>The value of the element.</td></tr>
            <tr><td class="param"> char * & <b>tmp</b></td><td>The temporary buffer to store the value until it's encoded.</td></tr>
        </table>
    </dd>

    <div id="add_unsigned" class="fnhead">add_unsigned</div>
    <dd>
        Adds a 32-bit unsigned integer to the structure.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the new element should be added.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
            <tr><td class="param">unsigned <b>c</b></td><td>The value of the element.</td></tr>
            <tr><td class="param"> char * & <b>tmp</b></td><td>The temporary buffer to store the value until it's encoded.</td></tr>
        </table>
    </dd>

    <div id="add_long64" class="fnhead">add_long64</div>
    <dd>
        Adds a 64-bit signed integer to the structure.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the new element should be added.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
            <tr><td class="param">long64 <b>c</b></td><td>The value of the element.</td></tr>
            <tr><td class="param"> char * & <b>tmp</b></td><td>The temporary buffer to store the value until it's encoded.</td></tr>
        </table>
    </dd>

    <div id="add_ulong64" class="fnhead">add_ulong64</div>
    <dd>
        Adds an 64-bit unsigned integer to the structure.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the new element should be added.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
            <tr><td class="param">ulong64 <b>c</b></td><td>The value of the element.</td></tr>
            <tr><td class="param"> char * & <b>tmp</b></td><td>The temporary buffer to store the value until it's encoded.</td></tr>
        </table>
    </dd>

    <div id="add_bool" class="fnhead">add_bool</div>
    <dd>
        Adds a boolean to the structure.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the new element should be added.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
            <tr><td class="param">bool <b>value</b></td><td>The value of the element.</td></tr>
        </table>
    </dd>

    <div id="add_null" class="fnhead">add_null</div>
    <dd>
        Adds a null value to the structure.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the new element should be added.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
        </table>
    </dd>

    <div id="add_double" class="fnhead">add_double</div>
    <dd>
        Adds a double value to the structure.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the new element should be added.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
            <tr><td class="param">double <b>c</b></td><td>The value of the element.</td></tr>
            <tr><td class="param">char * & <b>tmp</b></td><td>The temporary buffer to store the value until it's encoded.</td></tr>
            <tr><td class="param">byte <b>decimalPlaces = 6</b></td><td>The decimal places after the period.</td></tr>
        </table>
    </dd>

    <div id="add_printf" class="fnhead">add_printf</div>
    <dd>
        Does an sprintf to a temporary buffer and adds the resulting string to the structure.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the new element should be added.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
            <tr><td class="param">char * & <b>tmp</b></td><td>The temporary buffer to store the value until it's encoded.</td></tr>
            <tr><td class="param">const char * <b>format</b></td><td>A standard sprintf format string.</td></tr>
            <tr><td class="param">...</td><td>Additional parameters to be used by sprintf as defined in the format string.</td></tr>
        </table>
    </dd>

    <div id="add_printfv" class="fnhead">add_printfv</div>
    <dd>
        Does an sprintf to a temporary buffer and adds the resulting string to the structure. Uses va_list datatype for passing the arguments.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the new element should be added.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
            <tr><td class="param">char * & <b>tmp</b></td><td>The temporary buffer to store the value until it's encoded.</td></tr>
            <tr><td class="param">const char * <b>format</b></td><td>A standard sprintf format string.</td></tr>
            <tr><td class="param">va_list <b>ap</b></td><td>Additional parameters declared as va_list to be used by sprintf as defined in the format string.</td></tr>
        </table>
    </dd>

    <div id="add_hexstring" class="fnhead">add_hexstring</div>
    <dd>
        Converts a binary buffer to a hex string and adds it to the structure, encoded as a JSON string.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the new element should be added.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
            <tr><td class="param">const byte * <b>hex</b></td><td>Arbitrary binary data.</td></tr>
            <tr><td class="param">word <b>hex_len</b></td><td>The number of bytes in the hex buffer.</td></tr>
            <tr><td class="param">char * & <b>tmp</b></td><td>The temporary buffer to store the value until it's encoded.</td></tr>
        </table>
    </dd>

    <div id="add_json" class="fnhead">add_json</div>
    <dd>
        Adds a raw JSON string to the structure. The string must have valid encoding. It will not be escaped by the library.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the new element should be added.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
            <tr><td class="param">const char * <b>value</b></td><td>The JSON string to be added.</td></tr>
            <tr><td class="param">dword <b>len</b></td><td>The number of bytes in value. Only needed if value is not null-terminated.</td></tr>
        </table>
    </dd>

    <div id="get_objectByName" class="fnhead">get_object (overloaded)</div>
    <dd>
        Gets an object by name.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word</td><td>The ID of the object or <a href="#JSON_ID_NONE">JSON_ID_NONE</a> if it's not found.</td></tr>
        </table>
    </dd>

    <div id="get_objectFromArray" class="fnhead">get_object (overloaded)</div>
    <dd>
        Gets the next object from an array.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">word & <b>last</b></td><td>A word reference that must have the value 0 for the first call. The value will be updated by the function call for each subsequent call. If the value is <a href="#JSON_ID_NONE">JSON_ID_NONE</a> the end of the array is reached.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word</td><td>The ID of the object or <a href="#JSON_ID_NONE">JSON_ID_NONE</a> if there are no more objects in the array.</td></tr>
        </table>
    </dd>

    <div id="get_arrayByName" class="fnhead">get_array (overloaded)</div>
    <dd>
        Gets an array by name.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word</td><td>The ID of the array or <a href="#JSON_ID_NONE">JSON_ID_NONE</a> if it's not found.</td></tr>
        </table>
    </dd>

    <div id="get_arrayFromArray" class="fnhead">get_array (overloaded)</div>
    <dd>
        Gets the next array from an array.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">word & <b>last</b></td><td>A word reference that must have the value 0 for the first call. The value will be updated by the function call for each subsequent call. If the value is <a href="#JSON_ID_NONE">JSON_ID_NONE</a> the end of the array is reached.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word</td><td>The ID of the array or <a href="#JSON_ID_NONE">JSON_ID_NONE</a> if there are no more objects in the array.</td></tr>
        </table>
    </dd>

    <div id="get_stringByName" class="fnhead">get_string (overloaded)</div>
    <dd>
        Gets a string by name.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char *</td><td>The value of the string or 0 if it's not found.</td></tr>
        </table>
    </dd>

    <div id="get_stringFromArray" class="fnhead">get_string (overloaded)</div>
    <dd>
        Gets the next string from an array.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">word & <b>last</b></td><td>A word reference that must have the value 0 for the first call. The value will be updated by the function call for each subsequent call. If the value is <a href="#JSON_ID_NONE">JSON_ID_NONE</a> the end of the array is reached.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char *</td><td>The value of the string or 0 if there are no more objects in the array.</td></tr>
        </table>
    </dd>

    <div id="get_intByName" class="fnhead">get_int (overloaded)</div>
    <dd>
        Gets a 32-bit signed integer by name.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
            <tr><td class="param">bool * <b>present</b></td><td>If specified, the value will be set to true if the element existed. false otherwise.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">int</td><td>The value of the element or 0 if it's not found.</td></tr>
        </table>
    </dd>

    <div id="get_intFromArray" class="fnhead">get_int (overloaded)</div>
    <dd>
        Gets the next 32-bit signed integer from an array.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">word & <b>last</b></td><td>A word reference that must have the value 0 for the first call. The value will be updated by the function call for each subsequent call. If the value is <a href="#JSON_ID_NONE">JSON_ID_NONE</a> the end of the array is reached.</td></tr>
            <tr><td class="param">bool * <b>present</b></td><td>If specified, the value will be set to true if the element existed. false otherwise.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">int</td><td>The value of the element or 0 if there are no more objects in the array.</td></tr>
        </table>
    </dd>

    <div id="get_unsignedByName" class="fnhead">get_unsigned (overloaded)</div>
    <dd>
        Gets a 32-bit unsigned integer by name.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
            <tr><td class="param">bool * <b>present</b></td><td>If specified, the value will be set to true if the element existed. false otherwise.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">dword</td><td>The value of the element or 0 if it's not found.</td></tr>
        </table>
    </dd>

    <div id="get_unsignedFromArray" class="fnhead">get_unsigned (overloaded)</div>
    <dd>
        Gets the next 32-bit unsigned integer from an array.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">word & <b>last</b></td><td>A word reference that must have the value 0 for the first call. The value will be updated by the function call for each subsequent call. If the value is <a href="#JSON_ID_NONE">JSON_ID_NONE</a> the end of the array is reached.</td></tr>
            <tr><td class="param">bool * <b>present</b></td><td>If specified, the value will be set to true if the element existed. false otherwise.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">dword</td><td>The value of the element or 0 if there are no more objects in the array.</td></tr>
        </table>
    </dd>

    <div id="get_long64ByName" class="fnhead">get_long64 (overloaded)</div>
    <dd>
        Gets a 64-bit signed integer by name.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
            <tr><td class="param">bool * <b>present</b></td><td>If specified, the value will be set to true if the element existed. false otherwise.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">long64</td><td>The value of the element or 0 if it's not found.</td></tr>
        </table>
    </dd>

    <div id="get_long64FromArray" class="fnhead">get_long64 (overloaded)</div>
    <dd>
        Gets the next 64-bit signed integer from an array.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">word & <b>last</b></td><td>A word reference that must have the value 0 for the first call. The value will be updated by the function call for each subsequent call. If the value is <a href="#JSON_ID_NONE">JSON_ID_NONE</a> the end of the array is reached.</td></tr>
            <tr><td class="param">bool * <b>present</b></td><td>If specified, the value will be set to true if the element existed. false otherwise.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">long64</td><td>The value of the element or 0 if there are no more objects in the array.</td></tr>
        </table>
    </dd>

    <div id="get_ulong64ByName" class="fnhead">get_ulong64 (overloaded)</div>
    <dd>
        Gets a 64-bit unsigned integer by name.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
            <tr><td class="param">bool * <b>present</b></td><td>If specified, the value will be set to true if the element existed. false otherwise.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">ulong64</td><td>The value of the element or 0 if it's not found.</td></tr>
        </table>
    </dd>

    <div id="get_ulong64FromArray" class="fnhead">get_ulong64 (overloaded)</div>
    <dd>
        Gets the next 64-bit unsigned integer from an array.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">word & <b>last</b></td><td>A word reference that must have the value 0 for the first call. The value will be updated by the function call for each subsequent call. If the value is <a href="#JSON_ID_NONE">JSON_ID_NONE</a> the end of the array is reached.</td></tr>
            <tr><td class="param">bool * <b>present</b></td><td>If specified, the value will be set to true if the element existed. false otherwise.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">ulong64</td><td>The value of the element or 0 if there are no more objects in the array.</td></tr>
        </table>
    </dd>

    <div id="get_boolByName" class="fnhead">get_bool (overloaded)</div>
    <dd>
        Gets a boolean by name.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
            <tr><td class="param">bool * <b>present</b></td><td>If specified, the value will be set to true if the element existed. false otherwise.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">bool</td><td>The value of the element or false if it's not found.</td></tr>
        </table>
    </dd>

    <div id="get_boolFromArray" class="fnhead">get_bool (overloaded)</div>
    <dd>
        Gets the next boolean from an array.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">word & <b>last</b></td><td>A word reference that must have the value 0 for the first call. The value will be updated by the function call for each subsequent call. If the value is <a href="#JSON_ID_NONE">JSON_ID_NONE</a> the end of the array is reached.</td></tr>
            <tr><td class="param">bool * <b>present</b></td><td>If specified, the value will be set to true if the element existed. false otherwise.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">bool</td><td>The value of the element or false if there are no more objects in the array.</td></tr>
        </table>
    </dd>

    <div id="get_bool_int" class="fnhead">get_bool_int (overloaded)</div>
    <dd>
        Gets a boolean or integer by name.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
            <tr><td class="param">int & <b>iret</b></td><td>Returns the integer value</td></tr>
            <tr><td class="param">bool * <b>present</b></td><td>If specified, the value will be set to 1 if the element existed and is bool, 2 if the value existed and is integer. Set to 0 otherwise</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">bool</td><td>The value of the element or false if it's not found.</td></tr>
        </table>
    </dd>

    <div id="get_doubleByName" class="fnhead">get_double (overloaded)</div>
    <dd>
        Gets a double value by name.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">const char * <b>name</b></td><td>The name of the element. Only used when it's is inside an object. Set to 0 otherwise.</td></tr>
            <tr><td class="param">bool * <b>present</b></td><td>If specified, the value will be set to true if the element existed. false otherwise.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">double</td><td>The value of the element or 0 if it's not found.</td></tr>
        </table>
    </dd>

    <div id="get_doubleFromArray" class="fnhead">get_double (overloaded)</div>
    <dd>
        Gets the next double value from an array.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">word & <b>last</b></td><td>A word reference that must have the value 0 for the first call. The value will be updated by the function call for each subsequent call. If the value is <a href="#JSON_ID_NONE">JSON_ID_NONE</a> the end of the array is reached.</td></tr>
            <tr><td class="param">bool * <b>present</b></td><td>If specified, the value will be set to true if the element existed. false otherwise.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">double</td><td>The value of the element or 0 if there are no more objects in the array.</td></tr>
        </table>
    </dd>

    <div id="get_flags" class="fnhead">get_flags (overloaded)</div>
    <dd>
        Gets the flags of an given element

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>handle</b></td><td>The ID of the element.</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr>
                <td class="param">double</td>
                <td>
                    The flags. The only relevant flag is JSON_FLAG_INCOMPLETE. It indicates that the element
                    using chunked decoding is not yet complete and should not be processed.
                </td>
            </tr>
        </table>
    </dd>

    <div id="to_url" class="fnhead">to_url</div>
    <dd>
        Helper function to encode the structure not as JSON but as URL arguments.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">char * <b>b</b></td><td>The output buffer.</td></tr>
            <tr><td class="param">word <b>l</b></td><td>The size of the output buffer.</td></tr>
            <tr><td class="param">const char * <b>prefix</b></td><td>Prefix to be used for the single elements. For elements nested within arrays or objects another prefix of the name of the array/object is added. The prefixes are sepearted by '.'</td></tr>
            <tr><td class="param">bool <b>cont</b></td><td>true indicates that the arguments are to be added to other arguments. This means a '&amp;' is put at the beginning</td></tr>
        </table>

        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word</td><td>The number of bytes that have been written to the output buffer.</td></tr>
        </table>
    </dd>

    <div id="get_index" class="fnhead">get_index</div>
    <dd>
        Gets the total number of variables in the object, including the root element.
        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word</td><td>The total number of variables.</td></tr>
        </table>
    </dd>

    <div id="get_name" class="fnhead">get_name</div>
    <dd>
        Gets the string value of the passed argument.
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>handle</b></td><td>Typically represents the key of the JSON-property and serves as a unique identifier for the corresponding structure or substructure.</td></tr>
        </table>
        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char*</td><td>The key name.</td></tr>
        </table>
    </dd>

    <div id="get_info" class="fnhead">get_info</div>
    <dd>
        Gets the value from the JSON key-value pair.
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>handle</b></td><td>Typically represents the key of the JSON-property and serves as a unique identifier for the corresponding structure or substructure.</td></tr>
        </table>
        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char*</td><td>The value of the corresponding key in a JSON key-value pair, if value is nonexistent NULL is returned</td></tr>
        </table>
    </dd>

    <div id="get_count" class="fnhead">get_count</div>
    <dd>
        Gets the length of info.
        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word</td><td>The count of info.</td></tr>
        </table>
    </dd>

    <div id="get_next" class="fnhead">get_next</div>
    <dd>
        Gets the next JSON element
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy where the element should be searched.</td></tr>
            <tr><td class="param">word <b>last</b></td><td>A word reference that must have the value 0 for the first call. The value will be updated by the function call for each subsequent call. If the value is <a href="#JSON_ID_NONE">JSON_ID_NONE</a> the end of the array is reached.</td></tr>
            <tr><td class="param">byte& <b>type</b></td><td>The expected type of the next element. If the type of upcoming element does not match, that element will be ignored.</td></tr>
            <tr><td class="param">byte& <b>flags</b></td><td>A flag indicating the expected data type of the value to be extracted (e.g., 0x01 for a string value).</td></tr>
            <tr><td class="param">const char* <b>name</b></td><td>Pointer to buffer, in which the next elements name(key) will be saved.</td></tr>
            <tr><td class="param">const char* <b>info</b></td><td>Pointer to buffer, in which the next elements string info will be saved.</td></tr>
        </table>
        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word</td><td>The id of the next JSON element.</td></tr>
        </table>
    </dd>

    <div id="get_valueByName" class="fnhead">get_value</div>
    <dd>
        The function searches the JSON string for a value that matches the specified flags and position in the hierarchy. If found, it returns a pointer to a constant character array representing the extracted value.
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy from where the search for the value should begin.</td></tr>
            <tr><td class="param">byte& <b>flags</b></td><td>A flag indicating the expected data type of the value to be extracted (e.g., 0x01 for a string value).</td></tr>
            <tr><td class="param">const char* <b>name</b></td><td>The function searches the JSON string for a value that matches the specified name and flags, and is present within the object hierarchy starting from the given base.</td></tr>
            <tr><td class="param"> bool* (optional) <b>name</b></td><td> A pointer to a boolean variable that can be used to store whether the value was found in the JSON string or not.</td></tr>
        </table>
        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char*</td><td>If found, it returns a pointer to a constant character array representing the extracted value.</td></tr>
        </table>
    </dd>

    <div id="get_valueLast" class="fnhead">get_value</div>
    <dd>
        The function searches the JSON string for a value that matches the specified flags and position in the hierarchy. If found, it returns a pointer to a constant character array representing the extracted value.
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">word <b>base</b></td><td>A reference point in the JSON object hierarchy from where the search for the value should begin.</td></tr>
            <tr><td class="param">byte& <b>flags</b></td><td>A flag indicating the expected data type of the value to be extracted (e.g., 0x01 for a string value).</td></tr>
            <tr><td class="param">word <b>last</b></td><td>A word reference that must have the value 0 for the first call. The value will be updated by the function call for each subsequent call. If the value is <a href="#JSON_ID_NONE">JSON_ID_NONE</a> the end of the array is reached.</td></tr>
            <tr><td class="param"> bool* (optional) <b>name</b></td><td> A pointer to a boolean variable that can be used to store whether the value was found in the JSON string or not.</td></tr>
        </table>
        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char*</td><td>If found, it returns a pointer to a constant character array representing the extracted value.</td></tr>
        </table>
    </dd>

    <div id="get_buffer" class="fnhead">get_buffer</div>
    <dd>
        Gets the buffer of the current JSON object.
        <h4>Return value</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">char*</td><td>The buffer of the object.</td></tr>
        </table>
    </dd>

    <div id="set_buffer" class="fnhead">set_buffer</div>
    <dd>
        Sets the buffer of the current JSON object.
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">char* <b>buffer</b></td><td>The buffer to be set.</td></tr>
        </table>
    </dd>

    <div id="trace" class="fnhead">trace</div>
    <dd>
        Prints the base JSON object in the self implemented form inside iprintf function.
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">class debug_printf *<b>dbg</b></td><td>A pointer to the object of the class debug_printf in which the iprintf function should be implemented</td></tr>
            <tr><td class="param">word<b>base</b></td><td>A reference point in the JSON object hierarchy.</td></tr>
            <tr><td class="param">word <b>level (optional)</b></td><td>A word reference that sets the verbose level of the trace.</td></tr>
        </table>
    </dd>

    <h1>Variables</h1>
    <div id="last" class="fnhead">char *last</div>
    <dd>
        A pointer to the last character encountered during JSON parsing or processing.
    </dd>

    <div id="name_last" class="fnhead">char *name_last</div>
    <dd>
        A pointer to the last character of the name of a JSON object or value.
    </dd>

    <div id="incomplete" class="fnhead">char *incomplete</div>
    <dd>
        A pointer to an incomplete JSON element (e.g., an object or array) that is still open and waiting for further elements or values, reference to <a href="#JSON_FLAG_INCOMPLETE">JSON_FLAG_INCOMPLETE</a>.
    </dd>

    <div id="max_item" class="fnhead">unsigend max_item</div>
    <dd>
        The maximum number of items, reference to <a href="#JSON_MAX_ITEM">JSON_MAX_ITEM</a>.
    </dd>

    <h1>Data types</h1>
    <h2>Defines</h2>
    <table style="margin-left: 20px">
        <tr><td><a name="JSON_MAX_ITEM"><b>JSON_MAX_ITEM</b></td><td>Represents the maximum number of items.</td></tr>

        <tr><td><a name="JSON_TYPE_OBJECT"><b>JSON_TYPE_OBJECT</b></td><td>Represents a JSON object.</td></tr>
        <tr><td><a name="JSON_TYPE_ARRAY"><b>JSON_TYPE_ARRAY</b></td><td>Represents a JSON array.</td></tr>
        <tr><td><a name="JSON_TYPE_VALUE"><b>JSON_TYPE_VALUE</b></td><td>Represents a JSON value.</td></tr>
        <tr><td><a name="JSON_TYPE_CONTENT_PACKET"><b>JSON_TYPE_CONTENT_PACKET</b></td><td>Represents a content packet in the JSON structure.custom data type that might be used by specific applications or libraries to store additional information or metadata related to the JSON structure. </td></tr>
        <tr><td><a name="JSON_TYPE_ANY"><b>JSON_TYPE_ANY</b></td><td>Represents any JSON element type.</td></tr>

        <tr><td><a name="JSON_FLAG_QUOTED"><b>JSON_FLAG_QUOTED</b></td><td>This flag indicates that a JSON value should be treated as a quoted string..</td></tr>
        <tr><td><a name="JSON_FLAG_INCOMPLETE"><b>JSON_FLAG_INCOMPLETE</b></td><td>This flag indicates that a JSON element, such as an object or an array, is not yet complete and may have more elements or values added to it in the future.</td></tr>
        <tr><td><a name="JSON_FLAG_COMPLETE"><b>JSON_FLAG_COMPLETE</b></td><td>This flag indicates that a JSON element, such as an object or an array, is complete and no more elements or values will be added to it.</td></tr>

        <tr><td><a name="JSON_ID_ROOT"><b>JSON_ID_ROOT</b></td><td>Represents the top-level element.</td></tr>
        <tr><td><a name="JSON_ID_NONE"><b>JSON_ID_NONE</b></td><td>Used if an element is not found.</td></tr>
    </table>

    <h1> Code Examples</h1>
    <p>
        The following examples demonstrate the library on the following JSON structure.
        <br /><pre><code class="json">{ 
    "name": "John Doe", 
    "age": 30, 
    "interests": [ 
        "programming", 
        "tv series", 
        "cooking"
    ],
    "address": {
        "street": "123 Street",
        "city": "City of New State",
        "state": "New State"
    },
    "email": "john.doe@aol.com"
}</code></pre>
    </p>

    <a name="Example_Encoding"><h2>Encoding</h2></a>
    <pre class="sample"><code style="language-cpp">char message[512];
char temp[64];
json_io json(message);
char* t = temp;
word base = json.add_object(JSON_ID_ROOT, 0);
json.add_string(base, "name", "John Doe");
json.add_unsigned(base, "age", 30, t);

word interests = json.add_array(base, "interests");
json.add_string(interests, nullptr, "programming");
json.add_string(interests, nullptr, "tv series");
json.add_string(interests, nullptr, "cooking");
    
word address = json.add_object(base, "address");
json.add_string(address, "street", "123 Street");
json.add_string(address, "city", "City of New State");
json.add_string(address, "state", "New State");

json.add_string(base, "email", "john.doe@aol.com");

json.add_string(interests, nullptr, "fishing"); // this will have no effect, cause "interests" handle is not valid any more

json.encode();
</code></pre>


    <a name="Example_Decoding"><h2>Decoding</h2></a>
    <pre class="sample"><code style="language-cpp">json_io json(message);
json.decode();

word base = json.get_object(JSON_ID_ROOT, 0);
const char* name = json.get_string(base, "name");
dword age = json.get_unsigned(base, "age");

const char* interest_values[4];
word interest_count = 0;
word interests = json.get_array(base, "interests");
word last = 0;

while (last != JSON_ID_NONE && interest_count < 4) {
    const char* value = json.get_string(interests, last);
    if (value) {
        interest_values[interest_count++] = value;
    }
}

word address = json.get_object(base, "address");
const char* street = json.get_string(address, "street");
const char* city = json.get_string(address, "city");
const char* state = json.get_string(address, "state");

const char* email = json.get_string(base, "email");
</code></pre>


</body>
</html>
